# KMP算法

1. 如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, ..., pj-1 = p0 p1, ..., pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1...pk-1对应着文本串si-k si-k+1...si-1，而后让pk跟si继续匹配。
2. 之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。
3. 因为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。
4. 而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。